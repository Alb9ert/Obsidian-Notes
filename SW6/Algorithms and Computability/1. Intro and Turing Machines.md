
![[1. Algorithms and Computability.pdf]]


Difference between the encoding of a number and the value itself
A table of 10 items entails a total number of combinations of $10^{10}$

Veritasium har en god video på 3x+1 problemet
https://www.youtube.com/watch?v=094y1Z2wpJg


# Setting the stage

## What is a problem?

- Is a given number a prime?
- Does a given graph have a path from a given source vertex to a given destination vertex?
- Can the thief put $250 worth of loot in his knapsack?
- Does a given program ever output `False`?

>[!quote] General format
>Yes/No questions over a (typically infinite) set of inputs

Decision problem => yes or no 

### Abstraction
There are too many different types of input.

The only thing we consider as input, are sequences of symbols

- A number encoded in binary or decimal
- A graph is encoded by (a linearization) of its adjacency matrix
- A program is given by its source code

### Formal languages
* An alphabet is a finite, nonempty set of letters.
* A word over an alphabet Σ is a finite sequence of letters from Σ.
* The empty string is denoted by ε (the unique empty sequence of letters).
* The concatenation of words w1 and w2 is the word w1w2.
* The length of a word w is denoted by |w | and defined as the number of letters in w .
* The set of all words over an alphabet Σ is denoted by Σ∗.
* A language over an alphabet Σ is a subset of Σ∗.

Let L1, L2 be two languages over Σ.
union:
L1 ∪ L2 = {w ∈ Σ∗ | w ∈ L1 or w ∈ L2}
intersection:
L1 ∩ L2 = {w ∈ Σ∗ | w ∈ L1 and w ∈ L2}
complement (w.r.t. Σ∗):
L1 = {w ∈ Σ∗ | w /∈ L1}
concatenation:
L1 · L2 = {w ∈ Σ∗ | w = w1w2 with w1 ∈ L1 and w2 ∈ L2}
Kleene star (iteration):
(L1)∗ = {w ∈ Σ∗ | w = w1w2 · · · wk for some k ≥ 0 and
wi ∈ L1 for all i ∈ {1, 2, . . . , k}}

Solving algorithm => determnining language membership
### Finite automata
![[Pasted image 20260212134447.png]]

Automata can be used for decision problems, as they give a yes or no.
## What is an algorithm?
still don't know lol

# Turing machine
An abstract computing design (Invented pre digital). 
An infinite tape of paper, divided into squares (often called cells).
Reading/writing head: A single square that is currently observed 
Example rules:
![[Pasted image 20260212135938.png]]
DFA kan laves til Turing Machine regler

## Deterministic Turing machine (DTM)
![[Pasted image 20260212140317.png]]

Tape alphabet = everything we can write on the tape, and empty cells is formally the blank symbol
Only 1 accepting state
Transition function: 
tager input state som ikke er reject eller accept og kigger på et symbol fra tape alphabet.  =>  function give new state, and new symbol to write on tape and a -1 or +1 (direction), kan ikke stå stille.

>[!tip] 
>* Initialization: w is on the tape (all other cells are blank), reading head is on first letter of w (if w is nonempty), in state s.
> * Execution: Apply transition function repeatedly until termination, thereby updating the tape contents, the state, and the position of the reading head.
>* Termination: Stop, if state t or r is reached.

## Configurations
Matematisk forklarer hvad stadie vi er i

![[Pasted image 20260212142314.png]]
q = current state
t = tape content (tao) applicable transition
l = current location of reading head

![[Pasted image 20260212142841.png]]


* The language of a DTM M (say with input alphabet Σ), denoted by L(M), is defined as 
	L(M) = {w ∈ Σ∗ | M accepts w }.
* A halting DTM is a DTM that halts on every input (so either accepts or rejects it).
* A language L is computable, if there is a halting DTM M such that L = L(M).
* A language L is computably-enumerable, if there is a DTM M such that L = L(M).
	But: M might not terminate on all inputs w /∈ L(M)!


## Excercises:

$$[s, T, 1], \tau(n) = [a, a, a, , ...]$$
$$[h, T, 2], T(n) = [\_, a, a, , ...] $$
$$[h, T, 3], T(n) = [\_, a, a, , ...] $$
$$[h, T, 4], T(n) = [\_, a, a, , ...] $$
$$[e, T, 3], T(n) = [\_, a, a, , ...] $$
$$[r, T, 4], T(n) = [\_, a, a, , ...] $$Terminate and reject

$$[s, T, 1], T(n) = [a, a, b, , ...] $$
$$[h, T, 2], T(n) = [\_, a, b, , ...] $$
$$[h, T, 3], T(n) = [\_, a, b, , ...] $$
$$[h, T, 4], T(n) = [\_, a, b, , ...] $$
$$[e, T, 3], T(n) = [\_, a, b, , ...] $$
$$[g, T, 2], T(n) = [\_, a, _, , ...] $$
$$[g, T, 1], T(n) = [\_, a, _, , ...] $$
$$[s, T, 2], T(n) = [\_, a, _, , ...] $$
$$[h, T, 3], T(n) = [\_, \_, _, , ...] $$
$$[e, T, 2], T(n) = [\_, \_, _, , ...] $$
$$[r, T, 1], T(n) = [\_, \_, _, , ...] $$