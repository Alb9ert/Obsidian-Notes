# C Vulnerabilities
## Buffer Overflow

A **buffer overflow** happens when a program writes more bytes into a buffer than
it can hold, overwriting adjacent memory (often other local variables, saved
frame pointers, return addresses, etc.).

- A fixed-size buffer is allocated in memory
- The buffer is filled beyond its capacity
- Memory regions next to the buffer are overwritten
- Effects range from crashes to unintended behavior, and sometimes control-flow hijacking

### Example 1 - Width-limited `scanf`, Still Too Large for the Buffer

Even if you use a width specifier, you must match it to the buffer size.

>[!info] `scanf()` with width specifiers
> `scanf("%Ns", buf)` reads **up to N characters** plus a null terminator (`'\0'`).
> This means it will write **N+1 bytes** total. Always ensure N+1 ≤ buffer size.
> 
> Example: for `char buf[20]`, use `"%19s"` to leave room for the `'\0'`.


```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
  long val = 0x41414141;
  char buf[20];

  printf("Correct val's value from 0x41414141?\n");
  printf("Here is your chance: ");
  scanf("%28s", buf); // BUG: allows up to 28 chars + '\0' into a 20-byte buffer

  printf("buf: %s\n", buf);
  printf("val: 0x%08lx\n", val);

  if (val == 0xdeadbeef) {
    system("/bin/sl");
  } else {
    printf("WAY OFF!!!!!\n");
    exit(1);
  }
}
```

Key point: `"%28s"` does **not** mean “safe”—it means “read up to 28 chars”.

If `buf` is 20 bytes, you want something like `"%19s"` (room for `'\0'`).

---

### Example 2 - `strcpy` with Attacker-controlled Input

`strcpy` copies until it hits a `'\0'`, with **no size limit**.

>[!info] `strcpy()`
> `strcpy(dest, src)` copies characters from `src` to `dest` **until it finds a `'\0'`**.
> It has **no size limit** and doesn't check if `dest` is large enough.
> 
> **Never use `strcpy()` with untrusted or variable-length input.**
> Prefer `strncpy()`, `strlcpy()`, or `snprintf()` with proper size bounds.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char **argv) {
  if (argc != 2) return -1;

  long val = 0x41414141;
  char buf[20];

  strcpy(buf, argv[1]); // BUG: may overflow buf, we dont check argv size

  if (val == 0xdeadbeef) {
    system("/bin/sl");
  } else {
    printf("WAY OFF!!!!!\n");
    exit(1);
  }

  return 0;
}
```

Key point: don’t use `strcpy` on untrusted/variable-length input.

---

### Example 3 — “I Used `strncpy`, so it’s safe” (still unsafe)

A common mistake is using `strlen(src)` as the count. this defeats the whole
point of bounding the copy.

>[!warning] `strncpy()` — not as safe as it sounds
> `strncpy(dest, src, n)` copies **at most n bytes** from `src` to `dest`.
> 
> **Two major gotchas:**
> 1. **It does NOT guarantee null-termination** if `src` is ≥ n bytes long.
> 2. The third parameter `n` should be `sizeof(dest)`, **not `strlen(src)`** — otherwise you gain no protection.
> 
> After calling `strncpy(buf, src, sizeof(buf))`, you should manually ensure termination:
> ```c
> buf[sizeof(buf) - 1] = '\0';
> ```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char **argv) {
  if (argc != 2) return -1;

  long val = 0x41414141;
  char buf[20];

  strncpy(buf, argv[1], strlen(argv[1])); // BUG: can copy > sizeof(buf), Should use size of buffer, not input

  if (val == 0xdeadbeef) {
    system("/bin/sl");
  } else {
    printf("WAY OFF!!!!!\n");
    exit(1);
  }

  return 0;
}
```

Key point: `strncpy` is not automatically safe. **you must bound by the destination size** and handle termination.

---

## Buffer Overread
A **buffer overread** happens when code reads past the end of a buffer. This can
leak memory contents (information disclosure) or crash.

- Imagine a buffer that stores 5 characters
- If the program reads 10 characters, it will also read 5 bytes that happen to
  be next in memory

>[!tip] C strings must be null-terminated
> Functions like `printf("%s", ...)`, `strlen()`, and `strcmp()` all expect a **null-terminated string** (ending in `'\0'`).
> 
> If your buffer is not null-terminated, these functions will **read past the end** until they find a `'\0'` somewhere in memory, causing:
> - Information leakage (buffer overread)
> - Crashes (segmentation fault)
> - Unpredictable behavior

### Example - `strncpy` May not NUL-terminate, Leading to Overread in `printf("%s")`

`strncpy(dst, src, sizeof(dst))` does **not** guarantee a terminating `'\0'` if `src` is at least `sizeof(dst)` bytes long.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char **argv) {
  long long a = 0x42;
  long long c = 0x4141414141414141;
  char buf[8];

  strncpy(buf, argv[1], sizeof(buf)); // may produce a non-terminated "string"
  printf("%s", buf);                  // BUG: reads past buf until a '\0' is found
}
```

Key point: printing as a C-string (`%s`) requires a properly terminated string.

## String Manipulation (Common Foot-guns)

C strings are NUL-terminated arrays of bytes; many bugs come from confusing:

- **buffer length** vs **string length**
- functions that **stop at NUL** (`strcpy`, `strlen`, `%s`) vs ones that operate
  on explicit lengths (`memcpy`, `fread`)

Safer patterns (conceptually):

- always track sizes
- prefer bounded operations and enforce termination when treating data as text

Example pattern for copying into a fixed buffer:

```c
// Conceptual safe pattern (one of several):
snprintf(buf, sizeof(buf), "%s", user_input);
```

>[!tip] `snprintf()` — a safer alternative
> `snprintf(dest, size, format, ...)` writes **at most `size` bytes** (including the `'\0'`).
> 
> It **always null-terminates** (unlike `strncpy`), making it safer for typical string operations:
> ```c
> snprintf(buf, sizeof(buf), "%s", user_input);
> ```
> 
> However, be aware: if the formatted string is longer than `size-1`, it will be **truncated**.

## Integer Overflow

## Stack Smashing

An attacker take advantage of a buffer overflow to control the program

- Execute arbitrary code
- Jump to existing code

![[Pasted image 20260211125109.png]]
Classic example
- Exploit a buffer overflow,
- Leave some binary code on the stack,
- Overwrite return pointer → point it to own buffer
- Program jumps to your code

# Stack Smashing Prevention
Non-executuable stack (mark stack as non-executable)

Address-Space-Layout Randomisation to avoid attacks on common libraries like Clib
Adress sanaitizers: runtime checks
Canaries

## Canaries
Insert special value before return adress
Check the canary matches the special value before returning
Value should be random and generated by the runtime envoirment

# Strange behaviors
Strange behavior of the compiler..

Running the compiler with optimization can lead to weird behavior

## Mitigation
Compiler options to see security problems