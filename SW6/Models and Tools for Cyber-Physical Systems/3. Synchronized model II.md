# Extended State Machines

## Switch

> I want the switch to turn on, when pressed. It should stay on for 10 seconds, and turn off unless pressed.

![[Pasted image 20260210123745.png]]

- X is a clock in this synchronous system
- Press is an [[events]]/signal notaed by "?" same as in Uupal
- Press 0 means nothing happens

### [[Events]]

### Guard
TODO: Move to separate note
Prerequsite to be true to change state
Math notation: ( *boolean expression* )

### Update
The updating of state variable when state changes or repeats
Math notation: -> *expression*

### Execution

$$
(\text{off},0)\xrightarrow{0}(\text{off},0)\xrightarrow{1}(\text{on},0)
\xrightarrow{0}(\text{on},1)\xrightarrow{0}(\text{on},2)\xrightarrow{0}\cdots
\xrightarrow{0}(\text{on},10)\xrightarrow{0}(\text{off},0)
$$

What happens:

- The system state is a pair $(\text{mode}, x)$, where $\text{mode}\in\{\text{off},\text{on}\}$ and $x$ is a counter.
- Starting at $(\text{off},0)$:
  - Input $0$ keeps it in $(\text{off},0)$ (no change while off).
  - Input $1$ switches the mode to **on** and sets/keeps the counter at $0$: $(\text{off},0)\to(\text{on},0)$.
  - Each subsequent input $0$ while in **on** increments the counter: $(\text{on},k)\to(\text{on},k+1)$, so it goes $(\text{on},0)\to(\text{on},1)\to\cdots\to(\text{on},10)$.
  - The final $0$ causes a transition back to **off** and resets the counter to $0$: $(\text{on},10)\to(\text{off},0)$ (this corresponds to the condition like $x\ge 10$ triggering a reset when the relevant input occurs).

So overall: one “press” ($1$) turns the switch on, then repeated $0$ inputs count up to 10, and after reaching the threshold it turns off and resets.

# Types of Components
### Mealy Machines (system)
If all components are finite-state components we call it a mealy machine
### Finite-State Components
If state variables range over finite types we can make finite-state component
The above example is not a finite state because there is no restriction on x
example of a restriction could be in the input:

$$
 int[0,10] x:=0
$$

### Combinational Components
Components without state variables

### Input-Enabled Components

> [!quote] Something should happen no matter the input

A component is **input-enabled** if, in **every** state, it can handle **every** possible input, i.e., it always has at least one valid reaction (produces some output and moves to some next state).

If a component is **not** input-enabled, it means it can **block** for some inputs in some states, so it implicitly makes assumptions about what inputs the environment will (not) provide.
## Determinism
### Deterministic Components
A component is deterministic if:
(1) it has a single initial state, and
(2) for every state s and input i, there is a unique state t and output o such that s –i/o-> t is a reaction

> [!quote] Same sequence of inputs should give the same outputs every time

> [!warning] Probabilistic usually follows a normal distribution

### Probabilistic
### Non-deterministic

### Double-delay

> [!quote] Whatever you input you should see as output after 2 rounds

### Compatibility of components
* Can have common input variables
* Cannot have common output variables
* Cannot have common state variables
* Should have same types of what they are connected with
* Inputs and outputs should have different naming
* The relation (<1 ∪ <2) of combined await-dependencies is acyclic

# Product
### Inputs of product
(01) If C1 has output variables O1 and C2 has output variables O2 then the product C1
|| C2 has output variables O1 ∪ O2

(02) If C1 has input variables I1 and C2 has input variables I2 then the product C1 ||
C2 has input variables (I1 ∪ I2) \ (O1 ∪ O2)
> [!quote] (02) A variable is an input of the product if it is an input of one of the components, and not an output of the other

### State of product

### Reaction of product


# Task Graph
To see dependencies of components => catch deadlock etc
Breakdown: System => component => tasks

Start by Splitting Reaction Code Into Tasks
![[Pasted image 20260210132351.png]]
Tasks should be executed in order (order it to get the expected outcome)

![[Pasted image 20260210133040.png]]
Possible
A1, A2, A3, A4
A1, A2, A4, A3
A1, A3, A2, A4

Not possible 
A1, A4...

Because 
A1 < A3 (A1 should happen before A3)
A2 < A4 
A1 < A4

I/O await dependencies: look at the input and see what inputs are dependent to produce the out

### Requirements of task graph
Notation: A’ <+ A means that there is a path from task A’ to task A in the task
graph using precedence edges
One task writes ONE output 

(01) The precedence relation < must be acyclic
(02) Each output variable is in the write-set of exactly one task
(03) Output/local variables are written before being read
(04) Tasks with write conflicts must be ordered
(05) The order of POSSIBLE execution must not influence output

# Interfaces
Simplify to show designer
![[Pasted image 20260210140255.png]]



# Composition
![[Pasted image 20260210141256.png]]

## Properties of composition
* If C1 has n1 states and C2 has n2 states then the product has (n1 x n2) states
### Commutative
### Associative

## Output hiding
Given a component C, and an output variable y, the result of hiding y in C,
written as C \ y, is basically the same component as C, but y is no longer an
output variable, and becomes a local variable

# Design strategies
### Bottom up
### Top-Down